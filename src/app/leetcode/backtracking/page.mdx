import { Border, CodeGroup, Container, Section } from '@/components';

export const leetData = {
  title: 'Backtracking',
  description: 'Backtracking algorithm pattern for leetcode style problems.',
  pathname: '/leetcode/backtracking',
  framework: 'leetcode',
  videoId: 'vqnZ9RhhkmY'
};

export const sections = [
  { index: 0, title: 'Description', id: 'about' },
  //SectionsStart
	{ index: 1, title: 'Binary Tree Paths', id: 'binary-tree-paths.easy' }
	//SectionsEnd
];

export const metadata = {
  title: `${leetData.title}`,
  description: leetData.description,
};


<Container>
  <Section id={sections[0].id}>
    # Backtracking
    
    Backtracking is a technique where you use backtracking to solve a problem.
    The technique is often used to solve problems that can be broken down into a series of choices.
    
    <iframe className='w-full aspect-video mt-12'
      title='Youtube player'
      sandbox='allow-same-origin allow-forms allow-popups allow-scripts allow-presentation'
      src={`https://youtube.com/embed/${leetData.videoId}?autoplay=0&t=13`}>
    </iframe>

    <Border className="mt-6" />
    ### When:

    - Problems where you need to find all possible solutions
    - Problems where you need to find the best solution
    - Problems where you need to find the number of solutions
    - Problems where you need to find the smallest solution
    - Problems where you need to find the largest solution

    <Border className="mt-6" />
    
    ### Cases:

    - Backtracking algorithm that tries all possible solutions and backtracks when a solution is not valid.
    
  </Section>

  [//]: #ExamplesStart
    <Section id={sections[1].id} className="pt-2">
      <Border className="translate-y-5"/>
    
      ### Binary Tree Paths

      
      Given the root of a binary tree, return all root-to-leaf paths in any order.

      A leaf is a node with no children.

      #### Example 1:

      <strong>Input</strong>: root = [1,2,3,null,5]
      <br/><strong>Output</strong>: ["1->2->5","1->3"]

      #### Example 2:

      <strong>Input</strong>: root = [1]
      <br/><strong>Output</strong>: ["1"]

      #### Constraints:

      - The number of nodes in the tree is in the range [1, 100].
      - `-100 <= Node.val <= 100`
      
      <CodeGroup slug="binary-tree-paths">
        
      ```js
        /**
         * Definition for a binary tree node.
         * function TreeNode(val, left, right) {
         *     this.val = (val===undefined ? 0 : val)
         *     this.left = (left===undefined ? null : left)
         *     this.right = (right===undefined ? null : right)
         * }
         */
        /**
         * @param {TreeNode} root
         * @return {string[]}
         */
        var binaryTreePaths = function(root) {
            const res = [];
            if (!root) return res;

            const stack = [[root, `${root.val}`]];

            while (stack.length > 0) {
                const [node, path] = stack.pop();

                if (!node.left && !node.right) {
                    res.push(path);
                }

                if (node.right) {
                    stack.push([node.right, `${path}->${node.right.val}`]);
                }

                if (node.left) {
                    stack.push([node.left, `${path}->${node.left.val}`]);
                }
            }

            return res;
        };
      ```
    
      </CodeGroup>
      
    #### Explanation:

      1. Use a stack to simulate DFS: each entry is `[node, pathSoFar]`.
      2. Start with `[root, root.val]`.
      3. Pop a pair: if the node is a leaf (no left/right), push `pathSoFar` into the result.
      4. Otherwise push right then left onto the stack with `pathSoFar->child.val` so we explore and build paths without mutating a single path (no explicit backtrack step).
      5. Return the collected paths.
    
    </Section>
    [//]: #ExamplesEnd
</Container>

