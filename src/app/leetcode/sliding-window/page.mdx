import { Border, Container, Section } from '@/components';

export const leetData = {
  title: 'Sliding Window',
  description: 'Sliding window algorithm pattern for leetcode style problems.',
  pathname: '/leetcode/sliding-window',
  framework: 'leetcode',
  videoId: 'dOonV4byDEg'
};

export const sections = [
  { index: 0, title: 'Description', id: 'about' },
  //SectionsStart
	{ index: 1, title: 'Contains Duplicate II', id: 'contains-duplicate-ii.easy' }
	//SectionsEnd
];

export const metadata = {
  title: `${leetData.title}`,
  description: leetData.description,
};


<Container>
  <Section id={sections[0].id}>
    # Sliding Window

    The sliding window technique uses a fixed or variable-size window that moves across an array or string to avoid redundant work and achieve linear time for subarray/substring problems.

    {leetData.videoId && (
      <iframe className='w-full aspect-video mt-12'
        title='Youtube player'
        sandbox='allow-same-origin allow-forms allow-popups allow-scripts allow-presentation'
        src={`https://youtube.com/embed/${leetData.videoId}?autoplay=0`}>
      </iframe>
    )}

    <Border className="mt-6" />
    ### When:

    - Subarray or substring problems with a contiguous range
    - Problems asking for min/max length, sum, or count satisfying a condition
    - When a brute-force approach would re-scan the same elements repeatedly

    <Border className="mt-6" />

    ### Cases:

    - **Fixed window**: window size is given (e.g. max sum of subarray of size k).
    - **Variable window**: expand/contract window based on a condition (e.g. smallest subarray with sum ≥ target).
  </Section>


  [//]: #ExamplesStart
    <Section id={sections[1].id} className="pt-2">
      <Border className="translate-y-5"/>
    
      ### Contains Duplicate II

      
      Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) < = k.

      #### Example 1:

      <strong>Input</strong>: nums = [1,2,3,1], k = 3
      <br/><strong>Output</strong>: true

      #### Example 2:

      <strong>Input</strong>: nums = [1,0,1,1], k = 1
      <br/><strong>Output</strong>: true

      #### Example 3:

      <strong>Input</strong>: nums = [1,2,3,1,2,3], k = 2
      <br/><strong>Output</strong>: false

      #### Constraints:

      - `1 <= nums.length <= 105`
      - `-109 <= nums[i] <= 109`
      - `0 <= k <= 105`
      
      <CodeGroup slug="contains-duplicate-ii">
        
      ```js
        /**
         * @param {number[]} nums
         * @param {number} k
         * @return {boolean}
         */
        var containsNearbyDuplicate = function(nums, k) {
            const set = new Set();

            for (let i = 0; i < nums.length; i++) {
                // Remove the element that is now outside the window
                if (i > k) {
                    set.delete(nums[i - k - 1]);
                }

                // Check for duplicate in the current window
                if (set.has(nums[i])) {
                    return true;
                }

                // Add the current element to the window
                set.add(nums[i]);
            }

            return false;
        };
      ```
    
      </CodeGroup>
      
    #### Explanation:

      1. Maintain a sliding window of at most k elements using a Set.
      2. For each index i, if i > k, remove the element at index `i - k - 1` from the set (it's now outside the window).
      3. If the current element `nums[i]` is already in the set, we found two indices within distance k with the same value → return true.
      4. Otherwise add `nums[i]` to the set and continue.
      5. If the loop finishes without finding a duplicate in any window, return false.
    
    </Section>
    [//]: #ExamplesEnd
</Container>
